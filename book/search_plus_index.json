{"./":{"url":"./","title":"Notes","keywords":"","body":"笔记 这本笔记总结了一些零散的知识点，是我多年技术生涯的积累。 "},"docs/CRLF.html":{"url":"docs/CRLF.html","title":"CRLF","keywords":"","body":"CRLF CR ： Carriage Return ，对应 ASCII 中转义字符 \\r ，表示回车。 LF ： Line Feed ， 对应 ASCII 中转义字符 \\n ，表示换行。 CRLF ： Carriage Return & Line Feed ，对应 ASCII 中转义字符 \\r\\n ，表示回车并换行。 Windows 系统采用两个字符 CRLF 来进行换行。 而 Unix / Linux / macOS 系统采用单个字符 LF 来进行换行。 据野史记载，在很久以前的机械打字机时代， CR 和 LF 分别具有不同的作用： LF 会将打印纸张上移一行位置，但是保持当前打字的水平位置不变。 CR 则会将打字机上的滚动托架滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。当 CR 和 LF 组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。 随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如 Unix 的 LF 、 Macintosh 的 CR 。他们的意图都是为了进行换行操作，所以才有这样字符上的不同。 "},"docs/SOLID.html":{"url":"docs/SOLID.html","title":"SOLID","keywords":"","body":"SOLID S.O.L.I.D 是面向对象编程和面向对象设计的五个基本原则，应用这五个原则能创建一个易于维护和扩展的软件系统。 S.O.L.I.D 可以指导代码重构和在迭代的过程中进行代码清扫，以使得软件源代码清晰可读和具有良好的扩展性。在测试驱动开发中是典型应用场景，并且也是敏捷开发和自适应软件开发基本原则的重要组成部分。 单一功能原则（ S ） 开放封闭原则（ O ） 里氏替换原则（ L ） 接口隔离原则（ I ） 依赖反转原则（ D ） 单一功能原则（ S ） 让一个类只做一件事，如果需要承担更多的工作，那么分解这个类。 开放封闭原则（ O ） 类，模块，函数等应当对扩展开放，对修改闭合。 里氏替换原则（ L ） 当一个子类的实例应该能够替换任何其父类的实例时，它们之间才具有 IS-A 关系。 接口隔离原则（ I ） 不要强迫客户端去依赖那些他们不使用的接口。 依赖反转原则（ D ） 高层模块不应该依赖底层模块，两者都应该依赖其抽象。 抽象不应该依赖于细节，细节应该依赖于抽象。 "},"docs/原码-反码-补码.html":{"url":"docs/原码-反码-补码.html","title":"原码-反码-补码","keywords":"","body":"原码-反码-补码 原码 反码 补码 原码 原码是最简单的机器数表示法，用最高位表示符号位， 1 表示负号， 0 表示正号，其他位存放该数的二进制的绝对值。 2 的原码表示是 00000000 00000000 00000000 00000010 -1 的原码表示是 10000000 00000000 00000000 00000001 反码 正数的反码就是其原码，负数的反码就是其原码除符号位外，按位取反。 2 的反码表示是 00000000 00000000 00000000 00000010 -1 的反码表示是 11111111 11111111 11111111 11111110 补码 正数的补码就是其原码，负数的补码就是其反码 +1 。 2 的补码表示是 00000000 00000000 00000000 00000010 -1 的补码表示是 11111111 11111111 11111111 11111111 "},"docs/时间复杂度.html":{"url":"docs/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 每一位优秀的开发者脑海中都有时间概念，他们想给用户更多的时间，让用户做更多他们想做的事情。他们通过最小化时间复杂度来实现这一目的。 O(1) - 常量时间 O(log n) - 对数时间 O(n) - 线性时间 O(n^2) - 二次方时间 在理解程序的时间复杂度之前，需要了解最常使用它的地方，也就是算法设计。简单来说，算法就是一系列被控制的步骤，通过按序执行这些步骤可以实现一些目标或者产生一些输出。 1. 将烤箱预热到合适的温度 2. 混合面粉和酵母粉 3. 打发黄油和糖直到蓬松 4. 添加鸡蛋 5. 将黄油和鸡蛋混到面粉中 6. 添加牛奶 7. 继续搅拌 8. 放入烤箱开始烘烤 就如同可以用不同的方式来烘烤蛋糕一样，可以用多种不同的算法来解决同一个问题。有的解决方法效率更高，比其他的方法需要更少的时间和更少的空间。所以问题就是，怎么分析确认哪一个算法效率最高？数学！程序的时间复杂度分析不过是一个极其简单的数学方法，这种方法就是分析一个算法对于给定数量的输入需要多长时间来完成任务。这通常定义为大O表示法。 程序表达式 大O表示法 解释 2 O(1) 一个常数 2n + 10 O(n) n 对整体结果产生最大影响 5n^2 O(n^2) n^2 对整体结果产生最大影响 随着算法复杂度的提高，事情的复杂度也会以数量级增长。幸运的是，计算机足够强悍能够相对快速的处理非常复杂的问题。所以，我们应该怎样使用大O表示法来分析我们的代码？ O(1) - 常量时间 int main() { int a = 2; int b = 3; return a + b; } O(log n) - 对数时间 int main() { int a = 1; int num = 0; while (a O(n) - 线性时间 int main() { int sum = 0; for (int i = 0; i O(n^2) - 二次方时间 int main() { int sum = 0; for (int i = 0; i "},"docs/面试题.html":{"url":"docs/面试题.html","title":"面试题","keywords":"","body":"面试题 PHP "},"docs/面试题/PHP.html":{"url":"docs/面试题/PHP.html","title":"PHP","keywords":"","body":"PHP 垃圾回收机制 设置 Session 的生存时间 页面重定向的方法 使用正则表达式匹配 HTML 页面中所有 a 标签的 href 属性 验证 Email 格式 预定义变量 魔术变量 魔术方法 设计模式 类型比较表 echo (int) ((0.1 + 0.7) * 10) 使用单例模式建立数据库连接 冒泡排序 选择排序 [插入排序] [快速排序] 垃圾回收机制 垃圾回收机制 设置 Session 的生存时间 方法一： Memcache / Redis 方法二： 设置 session.cookie_lifetime 设置 session.gc_maxlifetime 设置 session.gc_probability 和 session.gc_divisor 方法三： 为每个 Session 的值添加一个对应的时间戳作为生存时间，在每次访问该值之前对时间戳进行判断。 页面重定向的方法 '; window.location.href=\"http://www.example.com\"'; 使用正则表达式匹配 HTML 页面中所有 a 标签的 href 属性 .*?/i', file_get_contents('https://github.com/'), $matches); var_dump($matches[1]); 验证 Email 格式 方法一： 方法二： 预定义变量 预定义变量 魔术变量 魔术常量 魔术方法 魔术方法 设计模式 phpdp 类型比较表 类型比较表 echo (int) ((0.1 + 0.7) * 10) 浮点数只能表示一个实数的近似值。 使用单例模式建立数据库连接 冒泡排序 依次比较相邻的两个元素，并根据元素的大小来进行排序，由于在排序的过程中总是较小的元素放在前面，较大的元素放在后面，类似于气泡往上升，所以称之为冒泡排序。 $array[$j + 1]) { $tmp = $array[$j + 1]; $array[$j + 1] = $array[$j]; $array[$j] = $tmp; } } } 选择排序 首先找到最小的元素，并将最小的元素放到最前面，然后再从剩余未排序的元素中继续寻找最小的元素进行排序，直到所有元素排序完毕。 $array[$j]) { $min = $j; } } if ($min != $i) { $tmp = $array[$min]; $array[$min] = $array[$i]; $array[$i] = $tmp; } } 插入排序 快速排序 "}}