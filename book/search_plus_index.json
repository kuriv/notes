{"./":{"url":"./","title":"Notes","keywords":"","body":"笔记 这本笔记总结了一些零散的知识点，是我多年技术生涯的积累。 "},"docs/充分条件与必要条件.html":{"url":"docs/充分条件与必要条件.html","title":"充分条件与必要条件","keywords":"","body":"充分条件与必要条件 假设 A 是条件， B 是结论，由 A ⇒ B ，则 A 是 B 的充分条件， B 是 A 的必要条件。 同理，假设 A 是条件， B 是结论，由 A ⇒ B ，由 B ⇒ A ，则 A 是 B 的充分必要条件。 例：X (X + 1) = 0 是 X = 0 的必要条件。 "},"docs/EM 还是 REM.html":{"url":"docs/EM 还是 REM.html","title":"EM 还是 REM","keywords":"","body":"EM 还是 REM EM REM EM 还是 REM EM em 是相对长度单位，它相对于当前元素的字体尺寸，即 font-size 。举例来说，如果当前元素的字体是 20px ，那么当前元素中的 em 就等于 20px 。 h1 { font-size: 20px; /* 1em = 20px */ } p { font-size: 16px; /* 1em = 16px */ } 如果当前元素没有指定字体大小，就需要根据其父元素的字体大小，来计算当前元素的字体大小。如果父元素是 ，且 元素的字体大小是 16px ，就可以计算出当前元素的字体大小是 32px 。 h1 { font-size: 2em; /* 2em = 32px */ } em 还能用来指定除字体大小意外的其它属性，像 margin 或 padding 等属性都可以用 em 来表示。 h1 { font-size: 2em; /* 2em = 32px */ margin-bottom: 1em; /* 1em = 32px */ } p { font-size: 1em; /* 1em = 16px */ margin-bottom: 1em; /* 1em = 16px */ } REM rem 是相对于根元素的长度单位，这里根元素就是 ，这意味着任何元素的 1rem 总是等于 中定义的字体大小。 h1 { font-size: 2rem; /* 2rem = 32px */ margin-bottom: 1rem; /* 1rem = 16px */ } p { font-size: 1rem; /* 1rem = 16px */ margin-bottom: 1rem; /* 1rem = 16px */ } EM 还是 REM 在项目开发中究竟是选用 rem 还是 em 一直以来争议不断，一些开发人员不使用 rem ，因为 rem 使组件不那么模块化；而另一些开发人员喜欢 rem 的简单性，即使用 rem 处理所有元素。 那么，在实际项目开发中，究竟是该使用 em 还是 rem 呢？答案是应该结合使用两者，利用各自的优势，从而实现较好代码质量和显示效果。当属性值的大小需要根据当前元素的字体大小缩放时，就使用 em ，其它的情况都使用更简单的 rem 。 "},"docs/CRLF.html":{"url":"docs/CRLF.html","title":"CRLF","keywords":"","body":"CRLF CR ： Carriage Return ，对应 ASCII 中转义字符 \\r ，表示回车。 LF ： Line Feed ， 对应 ASCII 中转义字符 \\n ，表示换行。 CRLF ： Carriage Return & Line Feed ，对应 ASCII 中转义字符 \\r\\n ，表示回车并换行。 Windows 系统采用两个字符 CRLF 来进行换行。 而 Unix / Linux / macOS 系统采用单个字符 LF 来进行换行。 据野史记载，在很久以前的机械打字机时代， CR 和 LF 分别具有不同的作用： LF 会将打印纸张上移一行位置，但是保持当前打字的水平位置不变。 CR 则会将打字机上的滚动托架滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。当 CR 和 LF 组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。 随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如 Unix 的 LF 、 Macintosh 的 CR 。他们的意图都是为了进行换行操作，所以才有这样字符上的不同。 "},"docs/SOLID.html":{"url":"docs/SOLID.html","title":"SOLID","keywords":"","body":"SOLID S.O.L.I.D 是面向对象编程和面向对象设计的五个基本原则，应用这五个原则能创建一个易于维护和扩展的软件系统。 S.O.L.I.D 可以指导代码重构和在迭代的过程中进行代码清扫，以使得软件源代码清晰可读和具有良好的扩展性。在测试驱动开发中是典型应用场景，并且也是敏捷开发和自适应软件开发基本原则的重要组成部分。 单一功能原则（ S ） 开放封闭原则（ O ） 里氏替换原则（ L ） 接口隔离原则（ I ） 依赖反转原则（ D ） 单一功能原则（ S ） 让一个类只做一件事，如果需要承担更多的工作，那么分解这个类。 开放封闭原则（ O ） 类，模块，函数等应当对扩展开放，对修改闭合。 里氏替换原则（ L ） 当一个子类的实例应该能够替换任何其父类的实例时，它们之间才具有 IS-A 关系。 接口隔离原则（ I ） 不要强迫客户端去依赖那些他们不使用的接口。 依赖反转原则（ D ） 高层模块不应该依赖底层模块，两者都应该依赖其抽象。 抽象不应该依赖于细节，细节应该依赖于抽象。 "},"docs/原码-反码-补码.html":{"url":"docs/原码-反码-补码.html","title":"原码-反码-补码","keywords":"","body":"原码-反码-补码 原码 反码 补码 原码 原码是最简单的机器数表示法，用最高位表示符号位， 1 表示负号， 0 表示正号，其他位存放该数的二进制的绝对值。 2 的原码表示是 00000000 00000000 00000000 00000010 -1 的原码表示是 10000000 00000000 00000000 00000001 反码 正数的反码就是其原码，负数的反码就是其原码除符号位外，按位取反。 2 的反码表示是 00000000 00000000 00000000 00000010 -1 的反码表示是 11111111 11111111 11111111 11111110 补码 正数的补码就是其原码，负数的补码就是其反码 +1 。 2 的补码表示是 00000000 00000000 00000000 00000010 -1 的补码表示是 11111111 11111111 11111111 11111111 "},"docs/浮点数.html":{"url":"docs/浮点数.html","title":"浮点数","keywords":"","body":"浮点数 浮点数的表示形式 32 位浮点数与 64 位浮点数 整数与浮点数的强制转换 浮点数的表示形式 (-1)^S 表示符号位，当 S = 0 ，浮点数为正数，反之，当S = 1 ，浮点数为负数。 M 表示有效数字，大于等于 1 且小于 2 。也就是说， M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。根据 IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1 ，因此可以被舍去，只保存后面的 xxxxxx 小数部分。 E 表示指数。根据 IEEE 754 规定， E 的真实值必须减去一个中间数。对于 32 位浮点数的 E ，这个中间数是 127 ，对于 64 位浮点数的 E ，这个中间数是 1023 。 当 E 不全为 0 或者不全为 1 ，指数 E 必须减去对应的中间数，并且将有效数字 M 加上第一位的 1 。当 E 全为 0 ，指数 E 等于 1 减去对应的中间数，并且有效数字 M 不再加上第一位的 1 ，而是还原为 0.xxxxxx 的小数，这样做是为了表示接近于 0 的很小的数字。当 E 全为 1 ，如果有效数字 M 全为 0 ，则表示这个数无穷大，如果有效数字 M 不全为 0 ，则表示这个数不是一个数。 32 位浮点数与 64 位浮点数 根据 IEEE 754 规定，对于 32 位浮点数，最高的 1 位是符号位 S ，然后跟着的 8 位是指数 E ，最后剩下的 23 位为有效数字 M 。 对于 64 位浮点数，最高的 1 位是符号位 S ，接着的 11 位是指数 E ，剩下的 52 位为有效数字 M 。 整数与浮点数的强制转换 #include int main(int argc, char const *argv[]) { int foo = 9; float *p = (float *)&foo; printf(\"%d\\n\", foo); // 9 printf(\"%f\\n\", *p); // 0.000000 return 0; } 9 => 00000000 00000000 00000000 00001001 => S = 0 => M = 00000000000000000001001 = 0.00000000000000000001001 => E = 00000000 = 1 - 127 = -126 => (-1)^0 × 0.00000000000000000001001 × 2^(-126) => 1.001 × 2^(-146) ≈ 0.000000 #include int main(int argc, char const *argv[]) { int foo = 9; float *p = (float *)&foo; *p = 9.0; printf(\"%d\\n\", foo); // 1091567616 printf(\"%f\\n\", *p); // 9.000000 return 0; } 9.0 => 1001.0 = 1.001 × 2^3 => S = 0 => M = 00100000000000000000000 => E = 3 + 127 = 130 = 10000010 => 01000001000100000000000000000000 = 1091567616 "},"docs/时间复杂度.html":{"url":"docs/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 每一位优秀的开发者脑海中都有时间概念，他们想给用户更多的时间，让用户做更多他们想做的事情。他们通过最小化时间复杂度来实现这一目的。 O(1) - 常量时间 O(log n) - 对数时间 O(n) - 线性时间 O(n^2) - 二次方时间 在理解程序的时间复杂度之前，需要了解最常使用它的地方，也就是算法设计。简单来说，算法就是一系列被控制的步骤，通过按序执行这些步骤可以实现一些目标或者产生一些输出。 1. 将烤箱预热到合适的温度 2. 混合面粉和酵母粉 3. 打发黄油和糖直到蓬松 4. 添加鸡蛋 5. 将黄油和鸡蛋混到面粉中 6. 添加牛奶 7. 继续搅拌 8. 放入烤箱开始烘烤 就如同可以用不同的方式来烘烤蛋糕一样，可以用多种不同的算法来解决同一个问题。有的解决方法效率更高，比其他的方法需要更少的时间和更少的空间。所以问题就是，怎么分析确认哪一个算法效率最高？数学！程序的时间复杂度分析不过是一个极其简单的数学方法，这种方法就是分析一个算法对于给定数量的输入需要多长时间来完成任务。这通常定义为大O表示法。 程序表达式 大O表示法 解释 2 O(1) 一个常数 2n + 10 O(n) n 对整体结果产生最大影响 5n^2 O(n^2) n^2 对整体结果产生最大影响 随着算法复杂度的提高，事情的复杂度也会以数量级增长。幸运的是，计算机足够强悍能够相对快速的处理非常复杂的问题。所以，我们应该怎样使用大O表示法来分析我们的代码？ O(1) - 常量时间 int main(int argc, char const *argv[]) { int foo = 2; int bar = 3; return foo + bar; } O(log n) - 对数时间 int main(int argc, char const *argv[]) { int foo = 1; int num = 100; int sum = 0; while (foo O(n) - 线性时间 int main(int argc, char const *argv[]) { int num = 10; int sum = 0; for (int i = 0; i O(n^2) - 二次方时间 int main(int argc, char const *argv[]) { int num = 10; int sum = 0; for (int i = 0; i "},"docs/TCP 三次握手与四次挥手.html":{"url":"docs/TCP 三次握手与四次挥手.html","title":"TCP 三次握手与四次挥手","keywords":"","body":"TCP 三次握手与四次挥手 标识位 字段 三次握手 四次挥手 TCP 的有限状态 标识位 标识位 含义 SYN（联机） 该位为 1 时，表示发起一个连接请求或接受请求报文 ACK（确认） 该位为 1 时，表示确认应答 TCP 规定，在连接建立后所有报文的传输都必须把 ACK 设置为 1 FIN（结束） 该位为 1 时，表示该报文发送方的数据已经发送完毕，并要求释放连接 字段 字段 含义 seq 序列号 ack 确认号 三次握手 TCP 建立连接的过程叫作握手，握手需要在客户端和服务器之间交换三个 TCP 报文，以下就是 TCP 建立连接的三次握手。 假设 A 运行的是 TCP 客户端程序，而 B 运行的是 TCP 服务端程序，两端最初的 TCP 进程都处于 CLOSED 状态。 B 的 TCP 进程首先创建传输控制块 TCB ，随后就处于 LISTEN 状态，准备接收来自 A 的连接请求。 A 的 TCP 进程也是首先创建传输控制块 TCB ，随后，在打算建立 TCP 连接时，向 B 发送连接请求报文，并将 SYN 设置为 1 ，同时选择一个初始序列号 seq = x 。此时， A 进入 SYN-SENT 状态。 B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认，并将 SYN 和 ACK 都设置为 1 （确认号 ack = x + 1 ），同时也为自已选择一个初始序列号 seq = y 。此时， B 进入 SYN-RCVD 状态。 A 收到确认后，还要向 B 发出确认，并将 ACK 设置为 1（确认号 ack = y + 1 ），而自己的序列号 seq = x + 1 。此时， A 进入 ESTABLISHED 状态。 当 B 收到 A 的确认后，也进入 ESTABLESHED 状态。此时，数据传送开始。 为什么不是两次握手？这主要是为了防止客户端已失效的连接请求报文突然又发送到服务端。 考虑一种正常情况， A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再次发送连接请求，随即收到确认、建立连接、传输数据、释放连接。 A 总共发送了两个连接请求报文，其中第一个丢失，第二个到达了 B ，没有已失效的连接请求报文。 现假设出现另一种异常情况，即 A 发出的第一个连接请求报文并没有丢失，而是在某些网络结点长时间滯留了，以致延误到第二个连接释放以后的某个时间才到达 B 。本来这是一个早已失效的报文，但 B 收到此失效的连接请求报文后，误认为是 A 又发出了一次新的连接请求，于是就向 A 回复确认报文，同意建立连接。假设不采用三次握手，那么只要 B 发出确认，新的连接就建立了，由于现在 A 并没有发出建立连接的请求，因此不会发送数据，但 B 却以为新的连接已经建立了，并且一直等待 A 发送数据，资源就这样白白浪费了。 四次挥手 握手后下个步骤是什么呢？分手吗？ TCP 释放连接的过程叫作挥手，挥手需要在客户端和服务器之间交换四个 TCP 报文，以下就是 TCP 释放连接的四次握手。 数据传输结束后，通信的双方都可以释放连接，现假设 A 和 B 都处于 ESTABLISHED 状态， A 发出连接释放报文，并停止发送数据，随后， A 将连接释放报文中的 FIN 设置为 1 ，其序列号 seq = u （等于前面已传送数据最后一个字节的序列号加 1 ）。此时， A 进入 FIN-WAIT-1 状态，等待 B 的确认。 B 收到连接释放报文后发出确认，确认号 ack = u + 1 ，其序列号 seq = v （等于前面已传送数据最后一个字节的序列号加 1 ） 。此时， B 进入 CLOSE-WAIT 状态。请注意，此时 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，如果 B 要发送数据， A 仍要接收，也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。 A 收到来自 B 的确认后，就进入 FIN-WAIT-2 状态。 现假定序列号 seq = w （半关闭状态下 B 又发送了一些数据），随后， B 将连接释放报文中的 FIN 设置为 1，同时重复上次已发送过的确认号 ack = u + 1 。此时， B 就进入 LAST-ACK 状态，等待 A 的确认。 A 在收到 B 的连接释放报文后，首先将确认报文中的 ACK 设置为 1 ，序列号 seq = u + 1 ，确认号 ack = w + 1 ，然后进入到 TIME-WAIT 状态。请注意，此时 TCP 连接还没有被完全释放掉，必须经过时间等待计时器设置的时间 2MSL 后， A 才进入到 CLOSED 状态。 为什么要必须等待 2MSL 的时间呢？主要有以下两个原因。 保证 A 发送的最后一个确认报文能够到达 B 。由于这个确认报文可能丢失，导致处在 LAST-ACK 状态下的 B 收不到确认，随即 B 会启动超时重传，而 A 就能在 2MSL 时间内收到这个重传的报文，接着 A 重传确认，重新启动 2MSL 计时器，最后， A 和 B 都能正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间， 而是在发送完确认报文后立即释放连接，那么就无法收到 B 重传的报文，这样 B 就无法按照正常步骤进入 CLOSED 状态。 消除超时过期的报文。 A 在发送完最后一个确认报文后，再经过 2MSL 时间，就可以使本连接持续的时间内所产生的报文都从网络中超时过期，这样就可以使下一个新的连接中不会出现这种旧的报文。 TCP 的有限状态 "},"docs/面试题.html":{"url":"docs/面试题.html","title":"面试题","keywords":"","body":"面试题 HTTP PHP "},"docs/面试题/HTTP.html":{"url":"docs/面试题/HTTP.html","title":"HTTP","keywords":"","body":"HTTP GET 方法和 POST 方法的区别 GET 方法和 POST 方法的区别 GET 方法和 POST 方法只是语义化的区别，以及不同的报文格式。 "},"docs/面试题/PHP.html":{"url":"docs/面试题/PHP.html","title":"PHP","keywords":"","body":"PHP 垃圾回收机制 设置 Session 的生存时间 页面重定向的方法 使用正则表达式匹配 HTML 页面中所有 a 标签的 href 属性 验证 Email 格式 预定义变量 魔术变量 魔术方法 设计模式 类型比较表 echo (int) ((0.1 + 0.7) * 10) 使用单例模式建立数据库连接 冒泡排序 选择排序 插入排序 快速排序 链表反转 获得上周一和上周日的日期 去除数组中键值为空的元素 去除数组中键值重复的元素 重新建立数组索引 对二维数组中多个键值相同的元素进行去重 使用正则表达式验证字符串不能为纯数字，不能为纯字母，并且不能包含彩票 / 广告等关键词 复制一个数组 N 次 抽象类和接口的区别 猴子选大王 发红包 斐波那契数列 二分查找 读取大文件 如何实现多继承 PHP 执行流程 自动加载的实现 单引号和双引号所包含的字符串的区别 递增递减运算符 类型转换的判别 字符串函数与大小写敏感 变量范围 三元运算符 传值和传引用的区别 从 URL 中获取文件的扩展名 判断键名是否存在于数组中 判断字符串是否是另一个字符串的子字符串 遍历目录中所有文件和子目录 配置优化 垃圾回收机制 垃圾回收机制 设置 Session 的生存时间 方法一： Memcache / Redis 方法二： 设置 session.cookie_lifetime 设置 session.gc_maxlifetime 设置 session.gc_probability 和 session.gc_divisor 方法三： 为每个 Session 的值添加一个对应的时间戳作为生存时间，在每次访问该值之前对时间戳进行判断。 页面重定向的方法 '; window.location.href=\"http://www.example.com\"'; 使用正则表达式匹配 HTML 页面中所有 a 标签的 href 属性 .*?/i', file_get_contents('https://github.com/'), $matches); var_dump($matches[1]); 验证 Email 格式 方法一： 方法二： 预定义变量 预定义变量 魔术变量 魔术常量 魔术方法 魔术方法 设计模式 phpdp 类型比较表 类型比较表 echo (int) ((0.1 + 0.7) * 10) 浮点数只能表示一个实数的近似值。 使用单例模式建立数据库连接 冒泡排序 依次比较相邻的两个元素，并根据元素的大小来进行排序，由于在排序的过程中总是较小的元素放在前面，较大的元素放在后面，类似于气泡往上升，所以称之为冒泡排序。 $array[$j + 1]) { $tmp = $array[$j + 1]; $array[$j + 1] = $array[$j]; $array[$j] = $tmp; } } } } 选择排序 首先找到最小的元素，并将最小的元素放到最前面，然后再从剩余未排序的元素中继续寻找最小的元素进行排序，直到所有元素排序完毕。 $array[$j]) { $min = $j; } } if ($min != $i) { $tmp = $array[$min]; $array[$min] = $array[$i]; $array[$i] = $tmp; } } } 插入排序 每次将一个等待排序的元素按其大小插入到前面已经排好序的适当的位置中，直到全部元素插入完成。 = 0; $j--) { if ($array[$j] > $tmp) { $array[$j + 1] = $array[$j]; $array[$j] = $tmp; } } } } 快速排序 快速排序是对冒泡排序的改进，首先通过一次排序将元素分成独立的两部分，其中一部分的元素均比另一部分的元素小，然后分别对这两部分继续进行快速排序，整个排序过程可以递归进行。 $array[0] ? $right[] = $array[$i] : $left[] = $array[$i]; } quickSort($left); quickSort($right); $array = array_merge($left, [$array[0]], $right); } 链表反转 方法一： next == null) { return $pHead; } $p = null; while ($pHead != null) { $tmp = $pHead->next; $pHead->next = $p; $p = $pHead; $pHead = $tmp; } return $p; } 方法二： next == null) { return $pHead; } $p = reverseList($pHead->next); $pHead->next->next = $pHead; $pHead->next = null; return $p; } 获得上周一和上周日的日期 去除数组中键值为空的元素 去除数组中键值重复的元素 重新建立数组索引 对二维数组中多个键值相同的元素进行去重 $value) { if (isset($value[$key1]) && isset($value[$key2])) { $string = $value[$key1] . $value[$key2]; if (in_array($string, $tmp)) { unset($array[$key]); } else { $tmp[] = $string; } } } } 使用正则表达式验证字符串不能为纯数字，不能为纯字母，并且不能包含彩票 / 广告等关键词 复制一个数组 N 次 抽象类和接口的区别 抽象类用于不同的事物，而接口用于事物的行为。 猴子选大王 1) { if ($i % $num != 0) { $array[] = $array[$i - 1]; } unset($array[$i - 1]); $i++; } return $array[$i - 1]; } 发红包 0) { return []; } $array = []; for (--$num; $num > 0; $num--) { $max = bcmul(bcsub($total, bcmul($num, $min)), $maxPercent); $tmp = bcdiv(mt_rand(bcmul($min, 100), bcmul($max, 100)), 100); $array[] = $tmp; $total = bcsub($total, $tmp); } $array[] = $total; return $array; } 斐波那契数列 方法一： 方法二： 二分查找 $num) { $right = $middle - 1; } elseif ($array[$middle] 读取大文件 生成器总览 如何实现多继承 Trait PHP 执行流程 词法分析，将 PHP 代码转换成语言片段。 语法分析，将语言片段转换成简单有意义的表达式。 编译，将表达式编译成操作码。 执行，顺序执行操作码，从而实现 PHP 脚本的功能，和机器指令运行相似。 自动加载的实现 单引号和双引号所包含的字符串的区别 单引号处理速度相对较快，双引号处理速度相对较慢。 双引号所包含的字符串会解析其中以 $ 开头的变量，而单引号则不解析。 递增递减运算符 类型转换的判别 字符串函数与大小写敏感 变量范围 三元运算符 $bar ? 4 : 5; echo $baz; // 4 传值和传引用的区别 传值是将实参的值赋值给形参，对形参的修改不会影响到实参的值。 传引用时传递的是实参的地址，对形参的修改将会影响到实参的值。 从 URL 中获取文件的扩展名 方法一： 方法二： 方法三： 判断键名是否存在于数组中 方法一： 方法二： 判断字符串是否是另一个字符串的子字符串 strlen($string2)) { $tmp = $string1; $string1 = $string2; $string2 = $tmp; } return strpos($string2, $string1) !== false; } 遍历目录中所有文件和子目录 配置优化 ;;;;;;;;;;;;;;;;;;;; ; Language Options ; ;;;;;;;;;;;;;;;;;;;; output_buffering = 4096 realpath_cache_size = 4096K realpath_cache_ttl = 120 ;;;;;;;;;;;;;;;;;;; ; Resource Limits ; ;;;;;;;;;;;;;;;;;;; max_execution_time = 30 memory_limit = 128M ;;;;;;;;;;;;;;;; ; File Uploads ; ;;;;;;;;;;;;;;;; file_uploads = On upload_max_filesize = 10M max_file_uploads = 20 ;;;;;;;;;;;;;;;;;;; ; Module Settings ; ;;;;;;;;;;;;;;;;;;; [Session] session.save_handler = redis [opcache] opcache.enable=1 "}}