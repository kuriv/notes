{"./":{"url":"./","title":"Notes","keywords":"","body":"笔记 这本笔记总结了一些零散的知识点，是我多年技术生涯的积累。 "},"docs/CRLF.html":{"url":"docs/CRLF.html","title":"CRLF","keywords":"","body":"CRLF CR ： Carriage Return ，对应 ASCII 中转义字符 \\r ，表示回车。 LF ： Line Feed ， 对应 ASCII 中转义字符 \\n ，表示换行。 CRLF ： Carriage Return & Line Feed ，对应 ASCII 中转义字符 \\r\\n ，表示回车并换行。 Windows 系统采用两个字符 CRLF 来进行换行。 而 Unix / Linux / macOS 系统采用单个字符 LF 来进行换行。 据野史记载，在很久以前的机械打字机时代， CR 和 LF 分别具有不同的作用： LF 会将打印纸张上移一行位置，但是保持当前打字的水平位置不变。 CR 则会将打字机上的滚动托架滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。当 CR 和 LF 组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。 随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如 Unix 的 LF 、 Macintosh 的 CR 。他们的意图都是为了进行换行操作，所以才有这样字符上的不同。 "},"docs/SOLID.html":{"url":"docs/SOLID.html","title":"SOLID","keywords":"","body":"SOLID S.O.L.I.D 是面向对象编程和面向对象设计的五个基本原则，应用这五个原则能创建一个易于维护和扩展的软件系统。 S.O.L.I.D 可以指导代码重构和在迭代的过程中进行代码清扫，以使得软件源代码清晰可读和具有良好的扩展性。在测试驱动开发中是典型应用场景，并且也是敏捷开发和自适应软件开发基本原则的重要组成部分。 单一功能原则（ S ） 开放封闭原则（ O ） 里氏替换原则（ L ） 接口隔离原则（ I ） 依赖反转原则（ D ） 单一功能原则（ S ） 让一个类只做一件事，如果需要承担更多的工作，那么分解这个类。 开放封闭原则（ O ） 类，模块，函数等应当对扩展开放，对修改闭合。 里氏替换原则（ L ） 当一个子类的实例应该能够替换任何其父类的实例时，它们之间才具有 IS-A 关系。 接口隔离原则（ I ） 不要强迫客户端去依赖那些他们不使用的接口。 依赖反转原则（ D ） 高层模块不应该依赖底层模块，两者都应该依赖其抽象。 抽象不应该依赖于细节，细节应该依赖于抽象。 "},"docs/原码-反码-补码.html":{"url":"docs/原码-反码-补码.html","title":"原码-反码-补码","keywords":"","body":"原码-反码-补码 原码 反码 补码 原码 原码是最简单的机器数表示法，用最高位表示符号位， 1 表示负号， 0 表示正号，其他位存放该数的二进制的绝对值。 2 的原码表示是 00000000 00000000 00000000 00000010 -1 的原码表示是 10000000 00000000 00000000 00000001 反码 正数的反码就是其原码，负数的反码就是其原码除符号位外，按位取反。 2 的反码表示是 00000000 00000000 00000000 00000010 -1 的反码表示是 11111111 11111111 11111111 11111110 补码 正数的补码就是其原码，负数的补码就是其反码 +1 。 2 的补码表示是 00000000 00000000 00000000 00000010 -1 的补码表示是 11111111 11111111 11111111 11111111 "},"docs/浮点数.html":{"url":"docs/浮点数.html","title":"浮点数","keywords":"","body":"浮点数 浮点数的表示形式 32 位浮点数与 64 位浮点数 整数与浮点数的强制转换 浮点数的表示形式 (-1)^S 表示符号位，当 S = 0 ，浮点数为正数，反之，当S = 1 ，浮点数为负数。 M 表示有效数字，大于等于 1 且小于 2 。也就是说， M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。根据 IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1 ，因此可以被舍去，只保存后面的 xxxxxx 小数部分。 E 表示指数。根据 IEEE 754 规定， E 的真实值必须减去一个中间数。对于 32 位浮点数的 E ，这个中间数是 127 ，对于 64 位浮点数的 E ，这个中间数是 1023 。 当 E 不全为 0 或者不全为 1 ，指数 E 必须减去对应的中间数，并且将有效数字 M 加上第一位的 1 。当 E 全为 0 ，指数 E 等于 1 减去对应的中间数，并且有效数字 M 不再加上第一位的 1 ，而是还原为 0.xxxxxx 的小数，这样做是为了表示接近于 0 的很小的数字。当 E 全为 1 ，如果有效数字 M 全为 0 ，则表示这个数无穷大，如果有效数字 M 不全为 0 ，则表示这个数不是一个数。 32 位浮点数与 64 位浮点数 根据 IEEE 754 规定，对于 32 位浮点数，最高的 1 位是符号位 S ，然后跟着的 8 位是指数 E ，最后剩下的 23 位为有效数字 M 。 对于 64 位浮点数，最高的 1 位是符号位 S ，接着的 11 位是指数 E ，剩下的 52 位为有效数字 M 。 整数与浮点数的强制转换 #include int main(int argc, char const *argv[]) { int a = 9; float *p = (float *)&a; printf(\"%d\\n\", a); // 9 printf(\"%f\\n\", *p); // 0.000000 return 0; } 9 => 00000000 00000000 00000000 00001001 => S = 0 => M = 00000000000000000001001 = 0.00000000000000000001001 => E = 00000000 = 1 - 127 = -126 => (-1)^0 × 0.00000000000000000001001 × 2^(-126) => 1.001 × 2^(-146) ≈ 0.000000 #include int main(int argc, char const *argv[]) { int a = 9; float *p = (float *)&a; *p = 9.0; printf(\"%d\\n\", a); // 1091567616 printf(\"%f\\n\", *p); // 9.000000 return 0; } 9.0 => 1001.0 = 1.001 × 2^3 => S = 0 => M = 00100000000000000000000 => E = 3 + 127 = 130 = 10000010 => 01000001000100000000000000000000 = 1091567616 "},"docs/时间复杂度.html":{"url":"docs/时间复杂度.html","title":"时间复杂度","keywords":"","body":"时间复杂度 每一位优秀的开发者脑海中都有时间概念，他们想给用户更多的时间，让用户做更多他们想做的事情。他们通过最小化时间复杂度来实现这一目的。 O(1) - 常量时间 O(log n) - 对数时间 O(n) - 线性时间 O(n^2) - 二次方时间 在理解程序的时间复杂度之前，需要了解最常使用它的地方，也就是算法设计。简单来说，算法就是一系列被控制的步骤，通过按序执行这些步骤可以实现一些目标或者产生一些输出。 1. 将烤箱预热到合适的温度 2. 混合面粉和酵母粉 3. 打发黄油和糖直到蓬松 4. 添加鸡蛋 5. 将黄油和鸡蛋混到面粉中 6. 添加牛奶 7. 继续搅拌 8. 放入烤箱开始烘烤 就如同可以用不同的方式来烘烤蛋糕一样，可以用多种不同的算法来解决同一个问题。有的解决方法效率更高，比其他的方法需要更少的时间和更少的空间。所以问题就是，怎么分析确认哪一个算法效率最高？数学！程序的时间复杂度分析不过是一个极其简单的数学方法，这种方法就是分析一个算法对于给定数量的输入需要多长时间来完成任务。这通常定义为大O表示法。 程序表达式 大O表示法 解释 2 O(1) 一个常数 2n + 10 O(n) n 对整体结果产生最大影响 5n^2 O(n^2) n^2 对整体结果产生最大影响 随着算法复杂度的提高，事情的复杂度也会以数量级增长。幸运的是，计算机足够强悍能够相对快速的处理非常复杂的问题。所以，我们应该怎样使用大O表示法来分析我们的代码？ O(1) - 常量时间 int main() { int a = 2; int b = 3; return a + b; } O(log n) - 对数时间 int main() { int a = 1; int num = 0; while (a O(n) - 线性时间 int main() { int sum = 0; for (int i = 0; i O(n^2) - 二次方时间 int main() { int sum = 0; for (int i = 0; i "},"docs/面试题.html":{"url":"docs/面试题.html","title":"面试题","keywords":"","body":"面试题 PHP "},"docs/面试题/PHP.html":{"url":"docs/面试题/PHP.html","title":"PHP","keywords":"","body":"PHP 垃圾回收机制 设置 Session 的生存时间 页面重定向的方法 使用正则表达式匹配 HTML 页面中所有 a 标签的 href 属性 验证 Email 格式 预定义变量 魔术变量 魔术方法 设计模式 类型比较表 echo (int) ((0.1 + 0.7) * 10) 使用单例模式建立数据库连接 冒泡排序 选择排序 插入排序 快速排序 [链表反转] 获得上周一和上周日的日期 去除数组中键值为空的元素 去除数组中键值重复的元素 重新建立数组索引 对二维数组中多个键值相同的元素进行去重 使用正则表达式验证字符串不能为纯数字，不能为纯字母，并且不能包含彩票 / 广告等关键词 复制一个数组 N 次 抽象类和接口的区别 [猴子选大王] [发红包] [斐波那契数列] [二分查找] [读取大文件] [如何实现多继承] [PHP 执行流程] 自动加载的实现 单引号和双引号所包含的字符串的区别 递增递减运算符 类型转换的判别 字符串函数与大小写敏感 变量范围 三元运算符 [传值和传引用的区别] 从 URL 中获取文件的扩展名 判断键名是否存在于数组中 判断字符串是否是另一个字符串的子字符串 [遍历目录中所有文件和子目录] 垃圾回收机制 垃圾回收机制 设置 Session 的生存时间 方法一： Memcache / Redis 方法二： 设置 session.cookie_lifetime 设置 session.gc_maxlifetime 设置 session.gc_probability 和 session.gc_divisor 方法三： 为每个 Session 的值添加一个对应的时间戳作为生存时间，在每次访问该值之前对时间戳进行判断。 页面重定向的方法 '; window.location.href=\"http://www.example.com\"'; 使用正则表达式匹配 HTML 页面中所有 a 标签的 href 属性 .*?/i', file_get_contents('https://github.com/'), $matches); var_dump($matches[1]); 验证 Email 格式 方法一： 方法二： 预定义变量 预定义变量 魔术变量 魔术常量 魔术方法 魔术方法 设计模式 phpdp 类型比较表 类型比较表 echo (int) ((0.1 + 0.7) * 10) 浮点数只能表示一个实数的近似值。 使用单例模式建立数据库连接 冒泡排序 依次比较相邻的两个元素，并根据元素的大小来进行排序，由于在排序的过程中总是较小的元素放在前面，较大的元素放在后面，类似于气泡往上升，所以称之为冒泡排序。 $array[$j + 1]) { $tmp = $array[$j + 1]; $array[$j + 1] = $array[$j]; $array[$j] = $tmp; } } } } 选择排序 首先找到最小的元素，并将最小的元素放到最前面，然后再从剩余未排序的元素中继续寻找最小的元素进行排序，直到所有元素排序完毕。 $array[$j]) { $min = $j; } } if ($min != $i) { $tmp = $array[$min]; $array[$min] = $array[$i]; $array[$i] = $tmp; } } } 插入排序 每次将一个等待排序的元素按其大小插入到前面已经排好序的适当的位置中，直到全部元素插入完成。 = 0; $j--) { if ($array[$j] > $tmp) { $array[$j + 1] = $array[$j]; $array[$j] = $tmp; } } } } 快速排序 快速排序是对冒泡排序的改进，首先通过一次排序将元素分成独立的两部分，其中一部分的元素均比另一部分的元素小，然后分别对这两部分继续进行快速排序，整个排序过程可以递归进行。 $array[0] ? $right[] = $array[$i] : $left[] = $array[$i]; } quickSort($left); quickSort($right); $array = array_merge($left, [$array[0]], $right); } 链表反转 获得上周一和上周日的日期 去除数组中键值为空的元素 去除数组中键值重复的元素 重新建立数组索引 对二维数组中多个键值相同的元素进行去重 $value) { if (isset($value[$key1]) && isset($value[$key2])) { $string = $value[$key1] . $value[$key2]; if (in_array($string, $tmp)) { unset($array[$key]); } else { $tmp[] = $string; } } } } 使用正则表达式验证字符串不能为纯数字，不能为纯字母，并且不能包含彩票 / 广告等关键词 复制一个数组 N 次 抽象类和接口的区别 抽象类用于不同的事物，而接口用于事物的行为。 猴子选大王 发红包 斐波那契数列 二分查找 读取大文件 如何实现多继承 PHP 执行流程 自动加载的实现 单引号和双引号所包含的字符串的区别 单引号处理速度相对较快，双引号处理速度相对较慢。 双引号所包含的字符串会解析其中以 $ 开头的变量，而单引号则不解析。 递增递减运算符 类型转换的判别 字符串函数与大小写敏感 变量范围 三元运算符 $bar ? 4 : 5; echo $baz; // 4 传值和传引用的区别 从 URL 中获取文件的扩展名 方法一： 方法二： 方法三： 判断键名是否存在于数组中 方法一： 方法二： 判断字符串是否是另一个字符串的子字符串 遍历目录中所有文件和子目录 "}}