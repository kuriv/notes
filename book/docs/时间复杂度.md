# 时间复杂度

> 每一位优秀的开发者脑海中都有时间概念，他们想给用户更多的时间，让用户做更多他们想做的事情。他们通过最小化时间复杂度来实现这一目的。

* [O(1) - 常量时间](#o1---常量时间)
* [O(log n) - 对数时间](#olog-n---对数时间)
* [O(n) - 线性时间](#on---线性时间)
* [O(n^2) - 二次方时间](#on2---二次方时间)

> 在理解程序的时间复杂度之前，需要了解最常使用它的地方，也就是算法设计。简单来说，算法就是一系列被控制的步骤，通过按序执行这些步骤可以实现一些目标或者产生一些输出。

```
1. 将烤箱预热到合适的温度
2. 混合面粉和酵母粉
3. 打发黄油和糖直到蓬松
4. 添加鸡蛋
5. 将黄油和鸡蛋混到面粉中
6. 添加牛奶
7. 继续搅拌
8. 放入烤箱开始烘烤
```

> 就如同可以用不同的方式来烘烤蛋糕一样，可以用多种不同的算法来解决同一个问题。有的解决方法效率更高，比其他的方法需要更少的时间和更少的空间。所以问题就是，怎么分析确认哪一个算法效率最高？数学！程序的时间复杂度分析不过是一个极其简单的数学方法，这种方法就是分析一个算法对于给定数量的输入需要多长时间来完成任务。这通常定义为大O表示法。

| 程序表达式 | 大O表示法 | 解释                       |
| ---------- | --------- | -------------------------- |
| 2          | O(1)      | 一个常数                   |
| 2n + 10    | O(n)      | n 对整体结果产生最大影响   |
| 5n^2       | O(n^2)    | n^2 对整体结果产生最大影响 |

> 随着算法复杂度的提高，事情的复杂度也会以数量级增长。幸运的是，计算机足够强悍能够相对快速的处理非常复杂的问题。所以，我们应该怎样使用大O表示法来分析我们的代码？

## O(1) - 常量时间

```c
int main()
{
    int a = 2;
    int b = 3;
    return a + b;
}
```

## O(log n) - 对数时间

```c
int main()
{
    int a = 1;
    int num = 0;
    while (a < 100)
    {
        a *= 2;
        num++;
    }
    return num;
}
```

## O(n) - 线性时间

```c
int main()
{
    int sum = 0;
    for (int i = 0; i < 10; i++)
    {
        sum += i;
    }
    return sum;
}
```

## O(n^2) - 二次方时间

```c
int main()
{
    int sum = 0;
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            sum += j;
        }
    }
    return sum;
}
```
