# 浮点数

* [浮点数的表示形式](#浮点数的表示形式)
* [32 位浮点数与 64 位浮点数](#32-位浮点数与-64-位浮点数)
* [整数与浮点数的强制转换](#整数与浮点数的强制转换)

## 浮点数的表示形式

![浮点数的表示形式](浮点数的表示形式.png)

> * (-1)^S 表示符号位，当 S = 0 ，浮点数为正数，反之，当S = 1 ，浮点数为负数。
>
> * M 表示有效数字，大于等于 1 且小于 2 。也就是说， M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。根据 IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1 ，因此可以被舍去，只保存后面的 xxxxxx 小数部分。
> * E 表示指数。根据 IEEE 754 规定， E 的真实值必须减去一个中间数。对于 32 位浮点数的 E ，这个中间数是 127 ，对于 64 位浮点数的 E ，这个中间数是 1023 。 **当 E 不全为 0 或者不全为 1** ，指数 E 必须减去对应的中间数，并且将有效数字 M 加上第一位的 1 。**当 E 全为 0** ，指数 E 等于 1 减去对应的中间数，并且有效数字 M 不再加上第一位的 1 ，而是还原为 0.xxxxxx 的小数，这样做是为了表示接近于 0 的很小的数字。**当 E 全为 1** ，如果有效数字 M 全为 0 ，则表示这个数无穷大，如果有效数字 M 不全为 0 ，则表示这个数不是一个数。

## 32 位浮点数与 64 位浮点数

> 根据 IEEE 754 规定，对于 32 位浮点数，最高的 1 位是符号位 S ，然后跟着的 8 位是指数 E ，最后剩下的 23 位为有效数字 M 。

![32 位浮点数](32 位浮点数.png)

> 对于 64 位浮点数，最高的 1 位是符号位 S ，接着的 11 位是指数 E ，剩下的 52 位为有效数字 M 。

![64 位浮点数](64 位浮点数.png)

## 整数与浮点数的强制转换

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int foo = 9;
    float *p = (float *)&foo;
    printf("%d\n", foo); // 9
    printf("%f\n", *p);  // 0.000000
    return 0;
}
```

```
9 => 00000000 00000000 00000000 00001001
  => S = 0
  => M = 00000000000000000001001 = 0.00000000000000000001001
  => E = 00000000 = 1 - 127 = -126
  => (-1)^0 × 0.00000000000000000001001 × 2^(-126)
  => 1.001 × 2^(-146) ≈ 0.000000
```

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int foo = 9;
    float *p = (float *)&foo;
    *p = 9.0;
    printf("%d\n", foo); // 1091567616
    printf("%f\n", *p);  // 9.000000
    return 0;
}
```

```
9.0 => 1001.0 = 1.001 × 2^3
    => S = 0
    => M = 00100000000000000000000
    => E = 3 + 127 = 130 = 10000010
    => 01000001000100000000000000000000 = 1091567616
```